package tk.igeek.aria2;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import android.R.string;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

public class Status extends CommonItem implements Parcelable {

	public Status(HashMap<String, Object> data) {
		init(data);
		initFiles();
		if (bittorrent != null) {
			bittorrentInfo.setData(bittorrent);
		}
	}

	/**
	 * GID of this download.
	 */
	public String gid = "";

	/**
	 * "active" for currently downloading/seeding entry. "waiting" for the entry
	 * in the queue; download is not started. "paused" for the paused entry.
	 * "error" for the stopped download because of error. "complete" for the
	 * stopped and completed download. "removed" for the download removed by
	 * user.
	 */
	public String status = "";

	/**
	 * 
	 Total length of this download in bytes.
	 */
	public String totalLength = "";

	/**
	 * 
	 Completed length of this download in bytes.
	 */
	public String completedLength = "0";

	/**
	 * 
	 Uploaded length of this download in bytes.
	 */
	public String uploadLength = "0";

	/**
	 * Hexadecimal representation of the download progress. The highest bit
	 * corresponds to piece index 0. The set bits indicate the piece is
	 * available and unset bits indicate the piece is missing. The spare bits at
	 * the end are set to zero. When download has not started yet, this key will
	 * not be included in the response.
	 */

	public String bitfield = "";

	/**
	 * 
	 Download speed of this download measured in bytes/sec.
	 */
	public String downloadSpeed = "0";

	/**
	 * 
	 Upload speed of this download measured in bytes/sec.
	 */
	public String uploadSpeed = "";

	/**
	 * 
	 InfoHash. BitTorrent only.
	 */
	public String infoHash = "";

	/**
	 * 
	 The number of seeders the client has connected to. BitTorrent only.
	 */
	public String numSeeders = "";

	/**
	 * 
	 Piece length in bytes.
	 */
	public String pieceLength = "";

	/**
	 * 
	 The number of pieces.
	 */
	public String numPieces = "0";

	/**
	 * 
	 The number of peers/servers the client has connected to.
	 */
	public String connections = "";

	/**
	 * The last error code occurred in this download. The value is of type
	 * string. The error codes are defined in EXIT STATUS section. This value is
	 * only available for stopped/completed downloads.
	 */
	public String errorCode = "";

	/**
	 * List of GIDs which are generated by the consequence of this download. For
	 * example, when aria2 downloaded Metalink file, it generates downloads
	 * described in it(see --follow-metalink option). This value is useful to
	 * track these auto generated downloads. If there is no such downloads, this
	 * key will not be included in the response.
	 */
	public Object[] followedBy = null;

	/**
	 * GID of a parent download. Some downloads are a part of another download.
	 * For example, if a file in Metalink has BitTorrent resource, the download
	 * of .torrent is a part of that file. If this download has no parent, this
	 * key will not be included in the response.
	 */
	public String belongsTo = "";

	/**
	 * Directory to save files. This key is not available for stopped downloads.
	 */
	public String dir = "";

	/**
	 * Returns the list of files. The element of list is the same struct used in
	 * aria2.getFiles method.
	 */
	public Object[] files = null;
	public ArrayList<Files> filesList = new ArrayList<Files>();

	/**
	 * Struct which contains information retrieved from .torrent file.
	 * BitTorrent only. It contains following keys.
	 */
	public HashMap<String, Object> bittorrent = null;
	private BitTorrent bittorrentInfo = new BitTorrent();

	
	public BitTorrent getBittorrent()
	{
		return bittorrentInfo;
	}
	
	enum DOWNLOAD_TYPE {
		UNKNOWN, HTTP_FTP, TORRENT, METALINK
	};

	long getTotalLength() {
		long uiRet = Long.parseLong(totalLength);
		if ((uiRet == 0) && (filesList.size() > 0)) {
			uiRet = Long.parseLong(filesList.get(0).length);
		}
		return uiRet;
	}

	public String getETA() {
		String sRet = "n/a";

		try {
			long ldownloadSpeed = Long.parseLong(downloadSpeed);
			if (ldownloadSpeed != 0) {
				long lcompletedLength = Long.parseLong(completedLength);
				long remsec = (getTotalLength() - lcompletedLength)
						/ ldownloadSpeed;
				long hr = remsec / 3600;
				remsec %= 3600;
				long min = remsec / 60;
				remsec %= 60;

				sRet = "";
				sRet += ((hr > 0) ? (hr + "h") : (""));
				sRet += ((min > 0) ? (min + "m") : (""));
				sRet += ((remsec > 0) ? (remsec + "s") : (""));
			}
		} catch (NumberFormatException e) {
			return "n/a";
		}
		return sRet;
	}

	public String getName() {
		String name = "unknow";
		DOWNLOAD_TYPE downloadType = DOWNLOAD_TYPE.HTTP_FTP;

		if (!numSeeders.equals("")) {
			downloadType = DOWNLOAD_TYPE.TORRENT;
		}

		switch (downloadType) {
		case HTTP_FTP:
			if (filesList.size() > 0) {
				name = filesList.get(0).path;
				if (name.equals("") && filesList.get(0).urisList.size() > 0) {
					name = filesList.get(0).urisList.get(0).uri;
				}
			}
			break;
		case TORRENT:
		case METALINK:
			if (bittorrentInfo.isHaveSetData() == true) {
				if (bittorrentInfo.mode.equals("multi")) {
					name = (String) bittorrentInfo.getInfoData().name;
				} else {
					name = filesList.get(0).path;
				}

			} else {
				name = filesList.get(0).path;
			}
			break;

		}

		return name;
	}

	private void initFiles() {
		if (files == null) {
			return;
		}
		for (Object file : files) {
			Files fileItem = new Files((HashMap<String, Object>) file);
			filesList.add(fileItem);
		}
	}

	public static final Parcelable.Creator<Status> CREATOR = new Parcelable.Creator<Status>() {

		@Override
		public Status createFromParcel(Parcel source) {
			return new Status(source);
		}

		@Override
		public Status[] newArray(int size) {
			return new Status[size];
		}
	};

	@Override
	public int describeContents() {
		return 0;
	}

	@Override
	public void writeToParcel(Parcel dest, int flags) {
		write(dest, flags);

	}

	private void readFromParcel(Parcel in) {
		read(in);
	}

	public Status(Parcel source) {
		readFromParcel(source);
	}

	public void write(Parcel dest, int flags) {
		Field[] fields = getClass().getFields();

		try {
			for (Field field : fields) {
				if (field.getModifiers() == Modifier.PUBLIC) {

					Object value = field.get(this);

					if (field.getType() == String.class) {
						dest.writeString((String) value);
					} else if (field.getName().equals("files")) {
						dest.writeTypedList(filesList);
					} else if (field.getName().equals("bittorrent")) {
						dest.writeParcelable(bittorrentInfo, flags);
					}

				}
			}
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
	}

	public void read(Parcel in) {

		Field[] fields = getClass().getFields();
		try {
			for (Field field : fields) {
				if (field.getModifiers() == Modifier.PUBLIC) {
					if (field.getType() == String.class) {
						field.set(this, in.readString());
					} else if (field.getName().equals("files")) {
						in.readTypedList(filesList, Files.CREATOR);
					} else if (field.getName().equals("bittorrent")) {
						bittorrentInfo = in.readParcelable(BitTorrent.class
								.getClassLoader());
					}
				}
			}
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
	}

	public boolean isTorrent()
	{
		if(!numSeeders.equals(""))
		{
			return true;
		}
		return false;
	}
	
	public CharSequence getRatio() {
		String sRet = "";
		if (isTorrent())
		{
			long lcompletedLength = Long.parseLong(completedLength);
			if (lcompletedLength > 0)
			{
				long luploadLength = Long.parseLong(uploadLength);
				DecimalFormat df = new DecimalFormat("#.##");
				sRet =  df.format((double)luploadLength / (double)lcompletedLength) + "%";
			}
			else
			{
				sRet = "0.000%";
			}
		}
		return sRet;
	}

}
